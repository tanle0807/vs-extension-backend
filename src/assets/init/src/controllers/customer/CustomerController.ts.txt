// IMPORT LIBRARY
import { Controller, UseAuth, Req, Get, Res, Response, HeaderParams, Post, BodyParams } from '@tsed/common';
import Joi from '@hapi/joi';
import { Docs } from '@tsed/swagger';
import { Request } from 'express';

// IMPORT CUSTOM
import { CustomerInsert } from './../../entity-request/CustomerInsert';
import { MailService } from './../../services/MailService';
import { Validator } from '../../middleware/validator/Validator';
import { VerificationJWT } from '../../middleware/auth/VerificationJWT';
import { Customer } from '../../entity/Customer';
import { CustomerService } from '../../services/CustomerService';
import JWT, { AuthType } from '../../middleware/auth/strategy/JWT';
import { CustomerUpdate } from '../../entity-request/CustomerUpdate';
import Password from '../../util/password';
import { randomString, getCurrentTimeInt } from '../../util/helper';

@Controller("/customer/customer")
@Docs("docs_customer")
export class CustomerController {
    constructor(
        private customerService: CustomerService,
        private mailService: MailService
    ) { }


    // =====================REGISTER=====================
    @Post('/register')
    @Validator({
        customer: Joi.required()
    })
    async register(
        @BodyParams('customer') customer: CustomerInsert,
        @Res() res: Response
    ) {
        const newCustomer = customer.toCustomer()
        await this.customerService.checkDuplicate(newCustomer)
        newCustomer.password = await Password.hash(newCustomer.password)
        await newCustomer.save()
        return res.sendOK(newCustomer)
    }


    // =====================LOGIN=====================
    @Post('/login')
    @Validator({
        phone: Joi.string().required(),
        password: Joi.string().required()
    })
    async login(
        @BodyParams('phone') phone: string,
        @BodyParams('password') password: string,
        @Res() res: Response
    ) {
        const user = await this.customerService.login(phone, password);
        if (!user)
            return res.sendClientError('Tài khoản hoặc mật khẩu không đúng! Vui lòng thử lại');
        if (user.isBlock)
            return res.sendClientError('Tài khoản này đã bị khoá!');
        const token = new JWT().sign({ id: user.id, type: AuthType.Customer });
        return { token };
    }


    // =====================INFO=====================
    @Get('/profile')
    @UseAuth(VerificationJWT)
    async getInfo(
        @Req() req: Request,
        @HeaderParams("token") token: string,
    ) {
        return await Customer.findOneOrThrowId(req.customer.id);
    }


    // =====================UPDATE INFO=====================
    @Post('/profile')
    @UseAuth(VerificationJWT)
    async updateInfo(
        @BodyParams("customer") customer: CustomerUpdate,
        @Req() req: Request,
        @Res() res: Response,
        @HeaderParams("token") token: string,
    ) {
        const modifiedCustomer = customer.toCustomer()
        modifiedCustomer.id = req.customer.id
        await modifiedCustomer.save()
        return res.sendOK(modifiedCustomer)
    }


    // =====================UPDATE PASSWORD=====================
    @Post('/profile/password/update')
    @UseAuth(VerificationJWT)
    @Validator({
        oldPassword: Joi.string().required(),
        newPassword: Joi.string().required()
    })
    async changePassword(
        @Req() req: Request,
        @HeaderParams("token") token: string,
        @BodyParams('oldPassword') oldPassword: string,
        @BodyParams('newPassword') newPassword: string,
        @Res() res: Response
    ) {
        const { id } = req.customer;
        if (oldPassword == newPassword)
            return res.sendClientError('Mật khẩu mới không được trùng mật khẩu cũ');

        // Get user with old password
        const customer = await this.customerService.isValidPassword(id, oldPassword);
        if (!customer)
            return res.sendClientError('Mật khẩu cũ không đúng')

        // Update password
        customer.password = await Password.hash(newPassword);
        await customer.save();
        return res.sendOK({}, 'Cập nhật mật khẩu thành công');
    }
    

    // =====================FORGOT=====================
    @Post('/password/forgot')
    @Validator({
        email: Joi.required(),
    })
    async forgot(
        @Req() req: Request,
        @Res() res: Response,
        @BodyParams("email") email: string,
    ) {
        const customer = await Customer.findOne({ where: { email } })
        if (!customer) {
            return res.sendClientError('Email không tồn tại')
        }
        const jwt = new JWT()
        const token = jwt.sign({ id: customer.id, type: AuthType.Customer, ia: getCurrentTimeInt() })
        this.mailService.sendMailLinkReset(token, customer)
        return res.sendOK({}, 'Vui lòng kiểm tra email và truy cập vào đường link xác nhận.')
    }


    // =====================CONFIRM FORGOT=====================
    @Post('/password/forgot/confirm')
    @Validator({
        token: Joi.required(),
    })
    async reForgot(
        @Req() req: Request,
        @Res() res: Response,
        @BodyParams("token") token: string
    ) {
        const jwt = new JWT()
        const customerId = jwt.getAuthId(token, AuthType.Customer)

        const customer = await Customer.findOne({ where: { id: customerId } })
        if (!customer) return res.sendClientError("Tài khoản không tồn tại")

        const ia = jwt.getIa(token)
        if (ia < customer.dateUpdated)
            return res.sendClientError("Yêu cầu đã hết hạn. Vui lòng gửi yêu cầu khác.")

        const newPassword = randomString(6)
        const hashed = await Password.hash(newPassword)
        customer.password = hashed
        await customer.save()

        this.mailService.sendMailReset(newPassword, customer)
        return customer
    }


} // END FILE
